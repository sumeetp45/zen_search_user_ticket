############################################################
#
# Code challenge : 25th July 2021
# 
# Program to process data across two json files and assist
#  user with search option
#
############################################################

package search_modules;

use strict;
use warnings;

use Getopt::Long;
use JSON;
use Cwd 'getcwd';

# To support UniCode characters in the json files
use utf8;
use Encode;
binmode(STDOUT, ":utf8");
binmode(STDIN, ":utf8");

my $max_number_of_words = 6;
my $max_length_of_string = 50;

my $LOG_FILE_HANDLE;

#############################
# process_json_files_and_start_search: 
#
# Start module for the search
#
sub process_json_files_and_start_search
{
    my ($data_hash) = @_;
    
    _logmsg("process_json_files_and_start_search: Start");
    
    _logmsg("process_json_files_and_start_search: calling process_json_files");
    process_json_files($data_hash);
    
    #
    # Start the search
    # 
    _logmsg("process_json_files_and_start_search: calling process search data");
    process_search_data($data_hash, "user_file_data", "ticket_file_data", "user_id_hash", "tickets_id_hash");
    
    _logmsg("process_json_files_and_start_search: Done");
    
    return;
}

#############################
# process_json_files: Start module for the search
#
# This module starts with checking for inputs.
# Then reads both the json files and does the processing of the data
# Finally calls the search to allow the user to search based on options
# 
# The hash structure explained below :
# 
# $data_hash - Primary top level hash. This contains all the keys, pointing to 
#       all the data that is read from json file to all the processed lists
# 
# user_file_data - Array of hashes. List of all the hash that contains all the data from the user json file 
#       This is generated by the JSON module decode function. Each hash has entries _id, name, created_at and verified
#       as keys and the value is the actual value read from the json file
#  
# user_id_hash - Points to a hash. The hash keys are the _id entries from the user json file. The value is an array  
#       pointing to the hash entries of user_file_data
# 
# users_with_missing_id - Array of hashes. List all user entries that have the entry of "_id" missing.
# 
# users_json_fields - Hash listing all the default fields of the user json file.
# 
# users_missing_default - Array of hashes. List all user entries that have either one or more of the default
#       fields of the user json file as missing.
# 
# users_extra_fields - Array of hashes. List all user entries that have either one or more of extra entries. 
#       Any field that is not in the users_json_fields
#  
# 
# ticket_file_data - Array of hashes. List of all the hash that contains all the data from the ticket json file 
#       This is generated by the JSON module decode function. Each hash has entries _id, type, created_at, subject,
#       assignee_id and tags (tags is array) as keys and the value is the actual value read from the json file
# 
# ticket_id_hash - Points to a hash. The hash keys are the assignee_id entries from the ticket json file. The value is an array  
#       pointing to the hash entries of ticket_file_data
# 
# tickets_with_missing_id - Array of hashes. List all ticket entries that have the entry of "assignee_id" missing.
# 
# tickets_json_fields - Hash listing all the default fields of the ticket json file.
# 
# tickets_missing_default Array of hashes. List all ticket entries that have either one or more of the default
#       fields of the ticket json file as missing.
# 
# tickets_extra_fields - Array of hashes. List all ticket entries that have either one or more of extra entries. 
#       Any field that is not in the tickets_json_fields 
# 
sub process_json_files
{
    my ($data_hash) = @_;
    
    _logmsg("process_json_files: Start");
    
    my ($ticket_file_path, $user_file_path) = check_inputs($data_hash, "inputopts");
    
    _logmsg("process_json_files: got files [$ticket_file_path and $user_file_path]");

    # Start processing of users json
    
    $data_hash->{"users_json_fields"} = {
        "_id" => 1,
        "name" => 1,
        "created_at" => 1,
        "verified" => 1
    };
    
    _logmsg("process_json_files: calling read json file for user json");
    read_json_file($data_hash, $user_file_path, "user_file_data");
    
    # TODO handle names in UTF-8 format (check id 35)
    
    process_json_data($data_hash, "user_file_data", "user_id_hash", "_id", 
        "users_with_missing_id", "users_json_fields", "users_missing_default", "users_extra_fields");

    # Start processing of ticket json
    
    $data_hash->{"tickets_json_fields"} = {
        "_id" => 1,
        "created_at" => 1,
        "type" => 1, 
        "subject" => 1, 
        "assignee_id" => 1,
        "tags" => 1
    };
    
    _logmsg("process_json_files: calling read json file for ticket json");
    read_json_file($data_hash, $ticket_file_path, "ticket_file_data");
    
    process_json_data($data_hash, "ticket_file_data", "tickets_id_hash", "assignee_id", 
        "tickets_with_missing_id", "tickets_json_fields", "tickets_missing_default", "tickets_extra_fields");

    return;
}

#############################
# process_search_data : 
# 
# This modules start after the json file data is processed.
# Lists two primary search options for user to select.
# 
sub process_search_data
{
    my ($data_hash, $key_user_data, $key_ticket_data, $user_id_hash, $ticket_id_hash) = @_;
    
    my $os = $^O;
    
    _logmsg("process_search_data: Start");
    
    while (1) {
        system("cls") if ($^O eq "MSWin32");
    
        print "\n\n======  Search users or tickets  ======\n";
        print "\n Search Options:\n";
        print "  1. Generic Search\n";
        print "  2. Specific Search\n";
        print "  3. Exit\n\n";
        my $input_msg = "Enter an option : ";
        my $input = get_input($input_msg);
    
        _logmsg("process_search_data: selected option is [$input]");
        
        while ($input !~ /\d/ || $input < 1 || $input > 3) {
            print "ERROR: the search option has to be a number from 1 to 3\n\n";
            _logmsg("process_search_data: the search option has to be a number from 1 to 3");
            $input = get_input($input_msg);
        }
        
        close_and_exit("process_search_data : User exit", 0) if (($input =~ /\d+/) && ($input == 3));
    
        if ($input == 1) {
            _logmsg("process_search_data: calling generic_search");
            generic_search($data_hash, $key_user_data, $key_ticket_data, $user_id_hash, $ticket_id_hash);
        }
        elsif ($input == 2) {
            _logmsg("process_search_data: calling specific_search");
            specific_search($data_hash, $key_user_data, $key_ticket_data, $user_id_hash, $ticket_id_hash);
        }
    }
    print "\n\nEnd program\n";
    _logmsg("process_search_data: Done");
}

#############################
# specific_search : 
# 
# Main module to perform the specific search. 
# It lists all the specific search options that the user can select from
# And based on the user choice, appropriate module is called to ask user
# input and then print the search result
#
sub specific_search
{
    my ($data_hash, $key_user_data, $key_ticket_data, $user_id_hash, $ticket_id_hash) = @_;
    
    my $os = $^O;
    
    _logmsg("specific_search: Start");
    
    while (1) {
        system("cls") if ($^O eq "MSWin32");
        print "\nSpecific Search : Following options available :- \n";
        print "  1. Search based on User ID\n";
        print "  2. Search based on any User name\n";
        print "  3. Search based on any Ticket field\n";
        print "  4. Unassigned tickets\n";
        print "  5. Users without IDs\n";
        print "  6. Check for anamolies (users missing fields or tickets with extra fields)\n";
        print "  7. Go to main menu\n";
        print "  8. Exit\n";
        
        my $input_msg = "\nEnter an option (1-8) :";
        my $input = get_input($input_msg);
        

        while ($input !~ /\d/ || $input < 1 || $input > 8) {
            print "ERROR: the search option has to be a number from 1 to 8\n\n";
            _logmsg("specific_search: the search option has to be a number from 1 to 8");
            $input = get_input($input_msg);
        }
        
        close_and_exit("specific_search : User exit", 0) if ($input == 8);
        return if ($input == 7);
        
        _logmsg("specific_search: provided input is [$input]");
        
        if ($input == 1) {
            _logmsg("specific_search: calling specific_search_based_on_user_id");
            specific_search_based_on_user_id($data_hash, $key_user_data, $key_ticket_data, $user_id_hash, $ticket_id_hash);
        }
        elsif ($input == 2) {
            _logmsg("specific_search: calling specific_search_based_on_user_name");
            specific_search_based_on_user_name($data_hash, $key_user_data, $key_ticket_data, $user_id_hash, $ticket_id_hash);
        }
        elsif ($input == 3) {
            _logmsg("specific_search: calling search_based_on_ticket_field");
            search_based_on_ticket_field($data_hash, $key_user_data, $key_ticket_data, $user_id_hash, $ticket_id_hash);
        }
        elsif ($input == 4) {
            _logmsg("specific_search: calling list_unassigned_users_or_tickets");
            print "\n Listing Tickets that have assigned_id missing or non-numeric value :\n\n";
            list_unassigned_users_or_tickets($data_hash, "", "tickets_with_missing_id", $user_id_hash, $ticket_id_hash);
        }
        elsif ($input == 5) {
            _logmsg("specific_search: calling list_unassigned_users_or_tickets");
            print "\n Listing Users that have _id missing or non-numeric value :\n\n";
            list_unassigned_users_or_tickets($data_hash, "users_with_missing_id", "", $user_id_hash, $ticket_id_hash);
        }
        elsif ($input == 6) {
            _logmsg("specific_search: calling check_for_anamolies");
            #check_for_anamolies($data_hash, "users_missing_default", "users_extra_fields", "tickets_missing_default", "tickets_extra_fields");
            print "\n Listing Users (if any) that have default entries (like name, _id) missing :\n\n";
            print_search_result($data_hash, "users_missing_default", "", $user_id_hash, $ticket_id_hash);
            
            print "\n Listing Users (if any) that have extra entries (like mobile, or DoB) in their json :\n\n";
            print_search_result($data_hash, "users_extra_fields", "", $user_id_hash, $ticket_id_hash);
            
            print "\n Listing Tickets (if any) that have default entries (like subject, type) missing :\n\n";
            print_search_result($data_hash, "", "tickets_missing_default", $user_id_hash, $ticket_id_hash);
            
            print "\n Listing Users (if any) that have extra entries in their json :\n\n";
            print_search_result($data_hash, "", "tickets_extra_fields", $user_id_hash, $ticket_id_hash);
        }
        get_input("\n\nPress enter to continue");
    }
    _logmsg("specific_search: Done");
}

#############################
# list_unassigned_users_or_tickets : 
# 
# This modules prints the anamolies that were detected in the
# json processing module. The users that have IDs missing, or the tickets that are not assigned
# 
sub list_unassigned_users_or_tickets
{
    my ($data_hash, $key_users_with_missing_id, $key_tickets_with_missing_id, $user_id_hash, $ticket_id_hash) = @_;
    
    _logmsg("list_unassigned_users_or_tickets: Start");
    
    print_search_result($data_hash, $key_users_with_missing_id, $key_tickets_with_missing_id, $user_id_hash, $ticket_id_hash);
    
    _logmsg("list_unassigned_users_or_tickets: Done");
}


#############################
# specific_search_based_on_user_name : 
# 
# This module searches for user names in the user json file
# This internally calls specific_hash_search_for_a_field
# 
sub specific_search_based_on_user_name
{
    my ($data_hash, $key_user_data, $key_ticket_data, $user_id_hash, $ticket_id_hash) = @_;
    
    _logmsg("specific_search_based_on_user_name: Start");
    
    my $to_search = "";
    print "\nSpecific Search : Search is case in-sensitive, but spaces between words will be matched as is\n";
    my $msg = "Enter a user name :";
    $to_search = get_input_string($msg);
    
    _logmsg("specific_search_based_on_user_name: name to search is [$to_search]");
    
    my $key_user_result = "user_results";
    specific_hash_search_for_a_field($data_hash, $key_user_data, $to_search, "name", $key_user_result);
    print_search_result($data_hash, $key_user_result, "", $user_id_hash, $ticket_id_hash);
    
    _logmsg("specific_search_based_on_user_name: Done");
}

#############################
# search_based_on_ticket_field : 
# 
# This module searches for a specific string in a particular field of the
# ticket jason.
# This internally calls specific_hash_search_for_a_field
# 
sub search_based_on_ticket_field
{
    my ($data_hash, $key_user_data, $key_ticket_data, $user_id_hash, $ticket_id_hash) = @_;
    
    _logmsg("search_based_on_ticket_field: Start");
    
    print "\nSpecific Search : Search is case in-sensitive, but spaces between words will be matched as is\n";
    print "Fields from Tickets json are :\n";
    
    my @ticket_fields = keys %{$data_hash->{"tickets_json_fields"}};
    
    my $index = 1;
    foreach my $t_field (@ticket_fields) {
        print "  $index. $t_field\n";
        $index++;
    }
    
    my $input_msg = "\nEnter an option :";
    my $input = get_input($input_msg);
    
    while ($input !~ /\d/ || $input < 1 || $input >= $index) {
        print "ERROR: the search option has to be a number\n\n";
        _logmsg("search_based_on_ticket_field: the search option has to be a number");
        $input = get_input($input_msg);
    }
    $index = $input;
    
    $input_msg = "\nEnter a value to search for the selected field :";
    my $to_search = get_input_string($input_msg);
    
    my $field = $ticket_fields[$index-1];
    _logmsg("search_based_on_ticket_field: need to search [$to_search] in field [$field]");
    
    my $key_ticket_result = "tickets_results";
    specific_hash_search_for_a_field($data_hash, $key_ticket_data, $to_search, $field, $key_ticket_result);
    print_search_result($data_hash, "", $key_ticket_result, $user_id_hash, $ticket_id_hash);
    
    _logmsg("search_based_on_ticket_field: Done");
}

#############################
# specific_hash_search_for_a_field : 
# 
# This module searches based on the field the users selects to search in.
# 
# The search time is linear to the number of entries in the json. But the
# search time of this will be better than the generic search
# Just itierate through each of the entries, pick up the field and search.
# 
sub specific_hash_search_for_a_field
{
    my ($data_hash, $data_key, $str_to_search, $field, $result_key) = @_;
    
    _logmsg("specific_hash_search_for_a_field: Start");
    
    delete $data_hash->{$result_key};
    foreach my $val (@{$data_hash->{$data_key}}) {
        next if (! exists $val->{$field});
        my $data = $val->{$field};
        #print "checking in [$data]\n";
        if (ref($data) eq 'ARRAY') {
            # Got a tag array of tickets_json 
            foreach my $tag (@{$data}) {
                #print "checking in tag [$tag]\n";
                if ($tag =~ m/$str_to_search/i) {
                    $data_hash->{$result_key} = [] if (! exists $data_hash->{$result_key});
                    push @{$data_hash->{$result_key}}, $val;
                    last;
                }
            }
        }
        elsif ($data =~ m/$str_to_search/i) {
            $data_hash->{$result_key} = [] if (! exists $data_hash->{$result_key});
            push @{$data_hash->{$result_key}}, $val;
        }
    }    
}

#############################
# specific_search_based_on_user_id : 
# 
# This module searches based on a specific user id.
# This will be the quickest search
# 
sub specific_search_based_on_user_id
{
    my ($data_hash, $key_user_data, $key_ticket_data, $user_id_hash, $ticket_id_hash) = @_;
    
    _logmsg("specific_search_based_on_user_id: Start");
    
    my $input_msg = "\nEnter a User ID to search :";
    my $input_id = get_input($input_msg);
    
    _logmsg("specific_search_based_on_user_id: got user input as [$input_id]");
    
    while ($input_id !~ /\d+/) {
        print "ERROR: the search ID has to be a number\n\n";
        _logmsg("specific_search_based_on_user_id: the search ID [$input_id] has to be a number");
        $input_id = get_input($input_msg);
    }
    
    my $user_details;
    my $ticket_details;
    
    #print "checking for id [$input_id]\n";
    
    my $key_user_result = "user_results";
    my $key_ticket_result = "tickets_results";
    
    # Clear the hash that stores the result.
    delete $data_hash->{$key_user_result};
    delete $data_hash->{$key_ticket_result};
        
    # Check if the ID exists in the hash for the user_id.
    if (exists $data_hash->{$user_id_hash}->{$input_id}) {
        
        _logmsg("specific_search_based_on_user_id: ID is valid. Calling print result");
            
        $data_hash->{$key_user_result} = $data_hash->{$user_id_hash}->{$input_id};
        print_search_result($data_hash, $key_user_result, $key_ticket_result, $user_id_hash, $ticket_id_hash);
            
        #foreach my $user (@{$data_hash->{$user_id_hash}->{$input_id}}) {
        #    print "user id has a match [$user->{name}]\n";
        #}
    }
    else {
        print "ERROR: ID [$input_id] does not exists\n";
        _logmsg("specific_search_based_on_user_id: ID [$input_id] does not exists");
    }
    _logmsg("specific_search_based_on_user_id: Done");
}

#############################
# generic_search : Generic search module
# 
# This gets invoked when the user runs a generic search, in which
# all the fields of both the jsons are checked for the search.
# The search results are in hash with pointers to the user or ticket json entries
# 
# The result is first the users that match and the their tickets
# Next the tickets that have the matching text and the users that have that ticket
# 
sub generic_search
{
    my ($data_hash, $key_user_data, $key_ticket_data, $user_id_hash, $ticket_id_hash) = @_;
    
    _logmsg("generic_search: Start");
    
    my $to_search = "";
    print "\nGeneric Search : Search is case in-sensitive, but spaces between words will be matched as is\n";
    my $msg = "Enter a search string :";
    $to_search = get_input_string($msg);
    
    _logmsg("generic_search: string to search is [$to_search]");

    _logmsg("generic_search: Searching the users json hash");
    my $user_result_key = "user_results";
    generic_hash_search($data_hash, $key_user_data, $to_search, $user_result_key);

    _logmsg("generic_search: Searching the tickets json hash");
    my $ticket_result_key = "tickets_results";
    generic_hash_search($data_hash, $key_ticket_data, $to_search, $ticket_result_key);
    
    _logmsg("generic_search: Printing the results");
    print_search_result($data_hash, $user_result_key, $ticket_result_key, $user_id_hash, $ticket_id_hash);
    
    _logmsg("generic_search: Done");
    get_input("\n\nPress enter to continue");
}

#############################
# get_input_string : 
# 
# Gets the input string that is required. 
# Checks if the string is valid or not and loops back
# if need the user to put the input again.
# 
sub get_input_string
{
    my ($msg) = @_;
    my $input_string = "";
    _logmsg("get_input_string: start. Input text is [$msg]");
    while (1) {
        my @input_arr = get_input($msg);
        $input_string = join("", @input_arr);

        _logmsg("get_input_string: got input [$input_string] and in array [@input_arr]");
        
        # Remove extra spaces between words. But this will break if the json file
        # has entries with extra spaces in the name or any other field
        # This can be solved by matching each word to word, instead of full string.
        # Lets take this as enhancement
        # $input_string =~ s/\s+/ /g;
        
        my $is_input_string_valid = is_input_search_string_valid($input_string);
        if (!$is_input_string_valid) {
            _logmsg("get_input_string: Incorrect input. Either lengthy string or no input");
            print "\nERROR : Incorrect input. Either lengthy string or no input\n";
            print "Enter search string with less than $max_number_of_words words and \n" . 
                "    max number of characters less than $max_length_of_string (including spaces)\n\n";
            next;
        }
        last;
    }
    _logmsg("get_input_string: returning input [$input_string]");
    return $input_string;
}

#############################
# search_start : Print search results
# 
# Accepts as primary data hash and the keys for results hash
# Loops through the result hash and calls appropriate print functions
# 
sub print_search_result
{
    my ($data_hash, $user_result_key, $ticket_result_key, $user_id_hash, $ticket_id_hash) = @_;
    
    _logmsg("print_search_result: start");
    
    if ((! exists $data_hash->{$user_result_key}) && (! exists $data_hash->{$ticket_result_key})) {
        _logmsg("print_search_result: empty hash. Means no matches found");
        print "\nNo matches found\n\n";
        return;
    }
    
    _logmsg("print_search_result: Printing Search Result");
    print "\n\n===========================\nPrinting Search Result:\n===========================\n\n";
    
    foreach my $user (@{$data_hash->{$user_result_key}}) {
        
        _logmsg("print_search_result: Printing user details");
        print "===========================\nUser with Matching details:\n\n";
        
        print_user_details($user);
        
        # After printing the user details, get the tickets that are
        # assigned to the user and print the ticket details.
        
        my $u_id = $user->{_id} if (exists $user->{_id});
        if (exists $data_hash->{$ticket_id_hash}->{$u_id}) {
            
            _logmsg("print_search_result: Printing the tickets of the user");
            print "\nUser has following ticket\/s:\n";
            
            foreach my $ticket (@{$data_hash->{$ticket_id_hash}->{$u_id}}) {
                print_ticket_details($ticket);
            }
        }
        print "\n\n";
    }
    
    _logmsg("print_search_result: Printing tickets that have a match for search string");
    
    # List through the tickets that were found in the search result, which matched
    # the string that was being searched.
    
    foreach my $ticket (@{$data_hash->{$ticket_result_key}}) {
        
        print "=====================================\nTickets with Matching the search string:\n\n";
        _logmsg("print_search_result: Print tickets with matching details");
        
        print_ticket_details($ticket);
        
        my $u_id = 0;
        $u_id = $ticket->{assignee_id} if (exists $ticket->{assignee_id});
        if ((exists $data_hash->{$user_id_hash}) && (exists $data_hash->{$user_id_hash}->{$u_id})) {
            
            # Now get the user/s that have this ticket assigned.
            _logmsg("print_search_result: Getting the users for the tickets matched in search");
            
            print "\n\n=================================\nUser that has this ticket:\n";
            foreach my $user (@{$data_hash->{$user_id_hash}->{$u_id}}) {
                print_user_details($user);
            }
        }
        print "\n\n";
    }
    _logmsg("print_search_result: Done");
}

#############################
# search_start : prints tickets details
# 
# Module accepts the ticket hash to print.
# Checks for each field if present prior to printing.
# #TODO check if the output printing format can be improved.
# 
sub print_ticket_details
{
    my ($ticket_hash) = @_;
    my ($t_id, $t_created_at, $t_type, $t_sub, $t_assignee_id) = "";
    
    _logmsg("print_ticket_details: start");
    
    $t_id = "No ID found";
    $t_id = $ticket_hash->{_id} if (exists $ticket_hash->{_id});
    
    $t_created_at = "No Created at found";
    $t_created_at = $ticket_hash->{created_at} if (exists $ticket_hash->{created_at});
    
    $t_type = "No type found";
    $t_type = $ticket_hash->{type} if (exists $ticket_hash->{type});
    
    $t_sub = "No subject found";
    $t_sub = $ticket_hash->{subject} if (exists $ticket_hash->{subject});
    
    $t_assignee_id = "000";
    $t_assignee_id = $ticket_hash->{assignee_id} if (exists $ticket_hash->{assignee_id});
    
    my $tags = "No tags found";
    $tags = join(", ", @{$ticket_hash->{tags}}) if (exists $ticket_hash->{tags});

    _logmsg("print_ticket_details: print details for ticket with id [$t_id]");
    print "\nFound ticket with following details :\n" .
        " Ticket type : " . $t_type . "   and subject as : \"" . $t_sub . "\"\n" .
        "  Ticket ID: " . $t_id . "    and created at : " . $t_created_at;
    print "\n  With tags : \"" . $tags . "\"\n";
    
    _logmsg("print_ticket_details: done");
}

#############################
# print_user_details : prints user details
# 
# Module accepts the user hash to print.
# Checks for each field if present prior to printing.
# #TODO check if the output printing format can be improved.
# 
sub print_user_details
{
    my ($user_hash) = @_;
    my ($u_name, $u_verified, $u_id, $u_created_at) = "";
    _logmsg("print_user_details: start");
    
    $u_name = "No name found";
    $u_name = $user_hash->{name} if (exists $user_hash->{name});
    
    $u_id = "000";
    $u_id = $user_hash->{_id} if (exists $user_hash->{_id});
    
    $u_created_at = "No Created at found";
    $u_created_at = $user_hash->{created_at} if (exists $user_hash->{created_at});
    
    $u_verified = "false";
    my $verified = $user_hash->{verified} if (exists $user_hash->{verified});
    $u_verified = "true" if ($verified);
    
    _logmsg("print_user_details: printing details for [$u_name]");
    
    # TODO append the output string when checking for each hash entry
    print "\nUser name is : " . $u_name . "\n";
    print "   User has ID: " . $u_id . ", verified is as : \"" . $u_verified . "\"\n" . 
        "   and created at value is : \"" . $u_created_at . "\"\n";
    _logmsg("print_user_details: Done");
}

#############################
# generic_hash_search : Generic hash search for a string
# 
# Generic search to go through the whole of the json fields and to search
# for the data.
# If a match is found, put the pointer in the result key
# 
sub generic_hash_search
{
    my ($data_hash, $data_key, $str_to_search, $result_key) = @_;
    
    _logmsg("generic_hash_search: searching for [$str_to_search] in [$data_key]");
    delete $data_hash->{$result_key};
    my $match = 0;
    foreach my $val (@{$data_hash->{$data_key}}) {
        $match = 0;
        foreach my $field (keys %{$val}) {
            next if ($match == 1);
            my $data = $val->{$field};

            if (ref($data) eq 'ARRAY') {
                # Got a tag array of tickets_json 
                #_logmsg("generic_hash_search: Got a tag entry which is an array");
                
                foreach my $tag (@{$data}) {
                    #_logmsg("generic_hash_search: checking in tag [$tag]");
                    
                    if ($tag =~ m/$str_to_search/i) {
                        _logmsg("generic_hash_search: Got a match in [$tag] for [$str_to_search]");
                        $data_hash->{$result_key} = [] if (! exists $data_hash->{$result_key});
                        push @{$data_hash->{$result_key}}, $val;
                        $match = 1;
                    }
                }
            }
            elsif ($data =~ m/$str_to_search/i) {
                _logmsg("generic_hash_search: Got a match in data [$data] for [$str_to_search]");
                $data_hash->{$result_key} = [] if (! exists $data_hash->{$result_key});
                push @{$data_hash->{$result_key}}, $val;
                $match = 1;
            }
        }
    }
    _logmsg("generic_hash_search: Done");
}

#############################
# is_input_search_string_valid : 
# 
# Checks if the input string is valid or not
# Fails for inputs with more than max number of words 
# or max length of the string
# 
sub is_input_search_string_valid
{
    my ($input_string) = @_;
    
    _logmsg("is_input_search_string_valid: called with input [$input_string]");
    
    my $length_of_str = length($input_string);
    
    _logmsg("is_input_search_string_valid: string length [$input_string] is [$length_of_str]");
    
    my @words = split /\s+/, $input_string;
    my $number_of_words = scalar @words;
    _logmsg("is_input_search_string_valid: number of words [$number_of_words]");
    
    if (($length_of_str == 0) || ($number_of_words > $max_number_of_words) || ($length_of_str > $max_length_of_string)) {
        _logmsg("is_input_search_string_valid: not a valid input");
        return 0;
    }
    # It is a valid string.
    return 1;
}

#############################
# entries_with_missing_or_extra_fields : TODO
# 
# Used it initially, but no longer used.
# 
# 
# 
sub entries_with_missing_or_extra_fields
{
    my ($data_hash, $key_missing_default) = @_;
    print "\n\nStarting : $key_missing_default\n";
    foreach my $entries (@{$data_hash->{$key_missing_default}}) {
        print "-----------------------\n";
        while (my ($field, $val) = each %{$entries}) {
            if (ref($val) eq 'ARRAY') {
                print "$field => [\n";
                foreach my $arr_val (@{$val}) {
                    print "     $arr_val\n";
                }
                print "]\n";
            }
            else {
                print "$field  =>  $val\n";
            }
        }
        print "-----------------------\n";
    }
    print "\n\n";
}

#############################
# process_json_data : The main function that does the data processing
# 
# Goes through the input file data and based on the id_field (_id in case of users json
# and assignee_id in case of tickets json), creates a hash on the ID.
# This hash on ID is used to search the data in case the users selects to do search on ID
# 
# Also this checks for anamolies in the json file, like the entries that have missing keys
# or the entries that have more entries than the default
#
sub process_json_data
{
    my ($data_hash, $key_file_data, $key_id_hash, $id_field, 
        $key_missing_id, $key_default_json_fields, $key_missing_default, $key_extra_fields) = @_;
    
    _logmsg("process_json_data : processing data for [$key_file_data]. Looking for ID [$id_field] and creating hash in [$key_id_hash]");
    $data_hash->{$key_id_hash} = {};
    $data_hash->{$key_missing_id} = [];
    $data_hash->{$key_missing_default} = [];
    $data_hash->{$key_extra_fields} = [];
    
    my $anamoly_in_json_field = 0;
    foreach my $val (@{$data_hash->{$key_file_data}}) {
        
        # Check if the $id_field (_id in case of users and assignee_id in case of tickets)
        # exists in this entry.
        # If the id_field does not exists or exists but it has a non-numeric
        # value, then push the pointer in the array of key_missing_id
        # If the id_field exists, push the pointer it in the array of key_id_hash.
        
        if ((! exists $val->{$id_field}) || ($val->{$id_field} !~ /\d+/)) {
            _logmsg("process_json_data : Got JSON entry in [$key_file_data] that does not have value [$id_field]");
            push @{$data_hash->{$key_missing_id}}, $val;
            
            # Since the id_field does not have the required value, add it to missing defaults
            push @{$data_hash->{$key_missing_default}}, $val;
            next;
        }
        else {
            if (! exists $data_hash->{$key_id_hash}->{$val->{$id_field}}) {
                $data_hash->{$key_id_hash}->{$val->{$id_field}} = [];
            }
            push @{$data_hash->{$key_id_hash}->{$val->{$id_field}}}, $val;
        }
        
        #_logmsg("process_json_data : Check if all the default json fields exists in this entry");
        
        # Check if all the default json fields exists in this entry. 
        # If anything missing, add the entry pointer to the missing default list
        $anamoly_in_json_field = 0;
        foreach my $default_fields (keys %{$data_hash->{$key_default_json_fields}}) {
            next if (exists $val->{$default_fields});
            my $id = $val->{"_id"};
            push @{$data_hash->{$key_missing_default}}, $val;
            $anamoly_in_json_field = 1;
            last;
        }
        
        next if ($anamoly_in_json_field == 1);
        
        #_logmsg("process_json_data : check if the entry has any extra fields than the default ones");
        
        # Check if the entry has any extra fields than the default ones
        # If yes, add the pointer to the list of extra fields
        foreach my $fields (keys %{$val}) {
            next if (exists $data_hash->{$key_default_json_fields}->{$fields});
            my $id = $val->{"_id"};
            _logmsg("process_json_data: Got an extra field [$fields] for [$id]");
            push @{$data_hash->{$key_extra_fields}}, $val;
        }
    }
    _logmsg("process_json_data : Done");
}

#############################
# search_start : ask for user input from the prompt
# 
# Prints the text sent and then waits for user input.
# Removes the extra spaces at the start and end of the input
# Converts the input into UTF-8 #TODO
# 
sub get_input 
{
    my ($msg) = @_;
    
    _logmsg("get_input: called for [$msg]");
    
    print $msg;
    my $input = <>;
    chomp($input);

    # Remove spaces (if any) provided while giving the
    # the inputs
    $input =~ s/\s*$//;
    $input =~ s/^\s*//;
    
    _logmsg("get_input: input is [$input]");
    $input = decode_utf8($input);
    
    _logmsg("get_input: input after UTF-8 [$input]");
    
    return $input;
}

#############################
# read_json_file : Reads the tickets and users json file
# 
# Opens the json files with UTF-8 encoding and then uses JSON module
# to decode the jsondata into perl hashes and array. The decode is called
# in eval block to catch any issues with the json file.
# 
sub read_json_file
{
    my ($data_hash, $json_file_path, $hkey) = @_;

     _logmsg("read_json_file - json_file_path is [$json_file_path] and key [$hkey]");
     if (open (H, "<:encoding(UTF-8)", $json_file_path) == 0) {
         _logmsg("read_json_file: Failed to open file path [$json_file_path]");
         print "read_json_file: Failed to open file path [$json_file_path]\n";
         close (H);
         close_and_exit("read_json_file : ERROR", 1);
     }
     my $jsondata = do { local $/; <H> };
     my $reginfo;
     eval {
         my $json = new JSON ();
         $reginfo = $json->decode($jsondata);
         $data_hash->{$hkey} = $reginfo;
         $jsondata = undef;
         };
     if ($@)
     {
         my $err = $@;
         _logmsg("read_json_file: Error reading [$json_file_path] and error is [$err]");
         print "read_json_file: Error reading json file [$json_file_path].\n" . 
            "Error is : $err\n";
         close (H);
         close_and_exit("read_json_file : ERROR", 1);
     }
     _logmsg("read_json_file: Returning from read_json_file");
     close (H);
}

#############################
# get_inputs : get inputs provided while executing the script
# 
# If help is provided as input, call usage and exit
# 
sub get_inputs
{
    my ($data_hash, $input_key) = @_;

    my %opts;
    GetOptions(\%opts,qw (help tickets_json=s users_json=s run_test));

    usage() if (exists $opts{help});

    $data_hash->{$input_key} = \%opts;

    _logmsg("Done with get_inputs");
}

#############################
# check_inputs : Check for inputs
# 
# If inputs for tickets and users json file path is not
# provided, then check if the files exists in the current directory
# 
sub check_inputs
{
    my ($data_hash, $input_key) = @_;
    
    my $input_hash = $data_hash->{$input_key};
    
    my $cwd_dir = getcwd();
    _logmsg("check_inputs: cwd is [$cwd_dir]");

    my $tfile = $cwd_dir . "\/tickets.json";
    my $ufile = $cwd_dir . "\/users.json";
    _logmsg("check_inputs: current directory paths are [$tfile] and [$ufile]");
    
    # If json file paths are not provided, check if the current directory has the files
    if((!exists $input_hash->{'tickets_json'}) && (!exists $input_hash->{'users_json'})) {
        if ((! -e $tfile) || (! -e $ufile)) {
            _logmsg("ERROR: check_inputs: Input file path not provided and current directory does not have either tickets.json or users.json files");
            usage();
            close_and_exit("check_inputs : ERROR", 1);
        }
    }
    # One of the file paths is provided as input. Check if it is users json and check
    # if the file exists. Also check if current dir has tickets json
    elsif (!exists $input_hash->{'tickets_json'}) {
        if ((! -e $tfile) || (! -e $input_hash->{'users_json'})) {
            _logmsg("ERROR: check_inputs: Input file path provided for users json, but either tickets.json or users.json does not exists");
            usage();
            close_and_exit("check_inputs : ERROR", 1);
        }
        $ufile = $input_hash->{'users_json'};
    }
    # One of the file paths is provided as input. Check if it is tickets json and check
    # if the file exists. Also check if current dir has users json    
    elsif (!exists $input_hash->{'users_json'}) {
        if ((! -e $input_hash->{'tickets_json'}) || (! -e $ufile)) {
            _logmsg("ERROR: check_inputs: Input file path provided for tickets json, but either tickets.json or users.json does not exists");
            usage();
            close_and_exit("check_inputs : ERROR", 1);
        }
        $tfile = $input_hash->{'tickets_json'};        
    }
    # Both the file paths are provided as input. Check if both the json files exists
    else {
        if ((! -e $input_hash->{'tickets_json'}) || (! -e $input_hash->{'users_json'})) {
            _logmsg("ERROR: check_inputs: Both input file path provided and either tickets.json or users.json files or both files does not exists");
            usage();
            close_and_exit("check_inputs : ERROR", 1);
        }        
        $tfile = $input_hash->{'tickets_json'};
        $ufile = $input_hash->{'users_json'};
    }
    _logmsg("check_inputs: Returning json files [$tfile] and [$ufile]");
    return ($tfile, $ufile);
}

#############################
# usage : Prints detailed usage of the script.
#
sub usage
{
    _logmsg("Usage called.");

    print "\n\nUsage: perl main_search.pl <OPTIONS>\n\n";

    print "OPTIONS :\n\n" .
          "   --tickets_json ......... [Optional] The full file path for tickets json file\n" .
          "                   ........   If not specified, the tickets.json file should exists\n" .
          "                   ........   in the current directory\n\n" .
          "   --users_json ........... [Optional] The full file path for users json file\n" .
          "                  .........   If not specified, the users.json file should exists\n" .
          "                  .........   in the current directory\n\n" .
          "   --run_test ............. [Optional] Run the test cases\n" .
          "   --help ................. [Optional] Prints this usage\n" .

          "\n\n   Examples:\n" .
          "     To run the script with both the json files in the current directory\n" .
          "        The json file names should match tickets.json and users.json\n" .
          "     # perl main_search.pl \n" .

          "\n\n     To run the script with the inputs from command line\n" .
          "     # perl main_search.pl --tickets_json=\"c:\\Users\\xyz\\test\\tickets_small.json\" \n" . 
          "           --users_json=\"C:\\Users\\xyz\\test\\users_small.json\"\n" .

          "\n\n     To run the script with the file path of tickets_json from command line\n" .
          "           and users.json exists in current directory\n" .
          "     # perl main_search.pl --tickets_json=\"c:\\Users\\xyz\\test\\tickets_small.json\" \n" .

          "\n\n     To run the script with the file path of users_json from command line \n" .
          "           and tickets.json exists in current directory\n" .
          "     # perl main_search.pl --users_json=\"C:\\Users\\xyz\\test\\users_small.json\"\n" .
          
          "\n\n     To run the script from a different folder, when all perl files are \n" .
          "           extracted in c:\\Users\\xyz\\test folder and json files are in current folder\n" .
          "     # perl -I c:\\Users\\xyz\\test\\ c:\\Users\\xyz\\test\\main_search.pl\n" .
          
          "\n\n     To run test coverage when all perl files and test_* perl modules and json files \n" .
          "           are extracted in c:\\Users\\xyz\\test folder and json files are in current folder\n" .
          "     # perl main_search.pl --run_test --tickets_json=\"c:\\Users\\xyz\\test\\test_tickets.json\" \n" .
          "           --users_json=\"C:\\Users\\xyz\\test\\test_users.json\"\n\n";          

    close_and_exit("Usage complete", 0);
    return;
}

#############################
# open_log_file_handle : Open the log file handle
# 
# Module to be called prior to calling _logmsg as this opens the log file. 
# Opens the file in append mode. If the open fails, error out.
# The log file is created in the current working directory
# 
sub open_log_file_handle
{
    # get the current working directory.
    # verified that this works with directory having spaces in the full path
    my $cwd_dir = getcwd();

    if (! -d $cwd_dir) {
        print "ERROR: Strangely the current folder is not directory. Check.\n\nExit\n";
        exit 1;
    }
    
    my $log_file_path = $cwd_dir . "\/search_user_ticket.log";
    #print "log file path is [$log_file_path]\n";
    
    if (open($LOG_FILE_HANDLE, '>>', $log_file_path) == 0) {
        print "ERROR: Unable to open log file [$log_file_path]. Check.\n\nExit\n";
        close $LOG_FILE_HANDLE; # Extra precaution.
        exit 1;
    }
    _logmsg("Begin");
}

#############################
# close_and_exit : Close file handle and exit
# 
# Module to close the log file handle and log the exit message
# Also exit based on the value sent
# 
sub close_and_exit
{
    my ($msg, $exit) = @_;
    _logmsg($msg);
    _logmsg("End");
    close $LOG_FILE_HANDLE;
    exit ($exit);
}

#############################
# _logmsg : Logs details.
# 
# Module to log messages in the log file and print them
# on the screen in case of errors.
# This module is dependent on the file handle to be valid, which is done 
# in module open_log_file_handle which is called at the start of the execution
# 
sub _logmsg
{
    my ($msg) = @_;
    
    # Get the process id and print it along with the log message.
    $msg = $$ . " : $msg";
    
    my $date = get_timestamp();
    if ($msg =~ m/begin|end/i) {
        $msg = "\n============================================\n    $msg : $date \n"
            . "============================================";
    }
    print $LOG_FILE_HANDLE "$date : $msg\n";
    print $msg if ($msg =~ m/ERROR/);
}

#############################
# get_timestamp : Returns the current date time.
# 
# This is used in the logging module to print logs with timestamp
# Timestamp helps in debugging purpose
# 
sub get_timestamp {
   my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
   $mon++;
   $year=$year+1900;
   return $year .'-'. $mon .'-'. $mday .' '. $hour .':'. $min .':'. $sec;
}

1;